# -*- coding: utf-8 -*-

"""
/***************************************************************************
 DissectAndDissolveOverlaps
                                 A QGIS plugin
 Detect, zoom to, dissect and dissolve overlaps in one polygon layer.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-02
        copyright            : (C) 2022 by Antonio Sobral Almeida
        email                : 66124.almeida@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Antonio Sobral Almeida'
__date__ = '2022-07-02'
__copyright__ = '(C) 2022 by Antonio Sobral Almeida'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'


from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterEnum
from qgis.core import QgsVectorLayer
import processing
import re 
import os
import time
from datetime import datetime
from qgis.core import QgsProject
from qgis.core import QgsProcessingUtils
from qgis.utils import iface
from PyQt5.QtWidgets import QAction
from qgis.core import QgsProcessingParameterFeatureSink
from PyQt5 import QtWidgets


class DissectAndDissolveOverlapsAlgorithm(QgsProcessingAlgorithm):

    OPTIONS = 'OPTIONS'
    option_list = ['Select and zoom to overlaps', 'Dissect overlaps','Dissect and Dissolve overlaps']
        
    def initAlgorithm(self, config=None):
        self.addParameter(QgsProcessingParameterVectorLayer('inputpolygonlayer', 'Input Polygon Layer', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterEnum(self.OPTIONS, options=self.option_list, allowMultiple=True,defaultValue=[0]))        
        self.addParameter(QgsProcessingParameterFeatureSink('Self_intersected', 'Self_intersected', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('Dissectedanddissolved', 'DissectedAndDissolved', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, supportsAppend=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(7, model_feedback)
        results = {}
        outputs = {}

        # Create a time stamp
        tme=time.localtime()
        timeString=datetime.now().strftime('%H%M%S')
        # Find options checked by user
        user_options = self.parameterAsEnums(parameters, self.OPTIONS, context)
        selected_items = [self.option_list[i] for i in user_options]

        # check which options are required by the user
        for l in selected_items:  
            find1 = re.findall("Select",l)  
            find2 = re.findall("Dissect",l)  
            find3 = re.findall("Dissolve",l)  
            
# *************************************************   Section1: Select and show overlaps   **************************************************************
        
        # This section will be allways executed, no matter user option
        
        # Unselect all selections
        iface.mainWindow().findChild(QAction, 'mActionDeselectAll').trigger()

        # Fix geometries
        alg_params = {
            'INPUT': parameters['inputpolygonlayer'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FixGeometries'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Get name and object of 'inputpolygonlayer' layer
        lyr_list = iface.layerTreeView().layerTreeModel().rootGroup().layerOrder()
        lyr_dict = {lyr.id(): lyr.name() for lyr in lyr_list}
        if parameters['inputpolygonlayer'] in lyr_dict:
            layer_name = lyr_dict[parameters['inputpolygonlayer']]
            input_layer = QgsProcessingUtils.mapLayerFromString(layer_name, context)
            iface.setActiveLayer(input_layer) 
        field_name = 'ID'
        field_index = input_layer.fields().indexOf(field_name)
        Flag1=[]
        if field_index > -1:  # i.e., there is no field named "ID"
            # Rename field
            alg_params = {
                'FIELD': 'ID',
                'INPUT': outputs['FixGeometries']['OUTPUT'],
                'NEW_NAME': 'ID_'+timeString,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RenameField'] = processing.run('native:renametablefield', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            Flag1.append(outputs['RenameField']['OUTPUT'])
        else: 
            Flag1.append(outputs['FixGeometries']['OUTPUT']) 

        # Add autoincremental field
        alg_params = {
            'FIELD_NAME': 'Id_SI',
            'GROUP_FIELDS': [''],
            'INPUT': Flag1[0],
            'MODULUS': 0,
            'SORT_ASCENDING': True,
            'SORT_EXPRESSION': '',
            'SORT_NULLS_FIRST': False,
            'START': 1,
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['AddAutoincrementalField'] = processing.run('native:addautoincrementalfield', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Polygon Self-Intersection
        alg_params = {
            'ID': 'Id_SI',
            'POLYGONS': outputs['AddAutoincrementalField']['OUTPUT'],
            'INTERSECT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['PolygonSelfintersection'] = processing.run('saga:polygonselfintersection', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        res1 = outputs['PolygonSelfintersection']['INTERSECT']

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Select by attribute
        alg_params = {
            'FIELD': 'ID',
            'INPUT': outputs['PolygonSelfintersection']['INTERSECT'],
            'METHOD': 0,  # creating new selection
            'OPERATOR': 7,  # contains
            'VALUE': '|'
        }
        outputs['SelectByAttribute'] = processing.run('qgis:selectbyattribute', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Extract selected features
        alg_params = {
            'INPUT': outputs['SelectByAttribute']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['ExtractSelectedFeatures'] = processing.run('native:saveselectedfeatures', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # Fix geometries2
        alg_params = {
            'INPUT': outputs['ExtractSelectedFeatures']['OUTPUT'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FixGeometries2'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        # Select by location
        alg_params = {
            'INPUT': parameters['inputpolygonlayer'],
            'INTERSECT': outputs['FixGeometries2']['OUTPUT'],
            'METHOD': 0,  # creating new selection
            'PREDICATE': [0] # intersect
        }
        outputs['SelectByLocation'] = processing.run('native:selectbylocation', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        
        # Zoom to selected features
        iface.actionZoomToSelected().trigger()
        
        # Check if there are selected features
        count_selected = input_layer.selectedFeatureCount() 
        if count_selected==0:
            w = QtWidgets.QWidget()
            b = QtWidgets.QLabel(w)
            w.setGeometry(400,400,550,20)
            w.setWindowTitle("There are no overlaps in the input layer! (Auto close in 10 seconds)")
            w.show()
            time.sleep(10)
            return results

        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}

# *************************************************   Section2: Dissect overlaps   **************************************************************
        # if user also selected option 'Dissect overlaps' or 'Dissect and dissolve overlaps'
        if find2 or find3:
            alg_params = {
                'ID': 'Id_SI',
                'POLYGONS': outputs['AddAutoincrementalField']['OUTPUT'],
                'INTERSECT': parameters['Self_intersected']
            }
            outputs['PolygonSelfintersection2'] = processing.run('saga:polygonselfintersection', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            res1 = outputs['PolygonSelfintersection2']['INTERSECT']

        if not find3:
            return results

        feedback.setCurrentStep(7)
        if feedback.isCanceled():
            return {}

# *************************************************   Section3: Dissolve overlaps   **************************************************************

        if find3:    # if user also selected option 'Dissolve overlaps'

            # Eliminate selected polygons
            alg_params = {
                'INPUT': outputs['SelectByAttribute']['OUTPUT'],
                'MODE': 0,  # Largest Area
                'OUTPUT': parameters['Dissectedanddissolved']
            }
            outputs['EliminateSelectedPolygons'] = processing.run('qgis:eliminateselectedpolygons', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            results['Dissectedanddissolved'] = outputs['EliminateSelectedPolygons']['OUTPUT']

        return results

    def name(self):
        return 'DissectAndDissolveOverlaps'

    def displayName(self):
        return 'Dissect and dissolve overlaps Ver. 0.2'

    def group(self):
        return ''

    def groupId(self):
        return ''

    def createInstance(self):
        return DissectAndDissolveOverlapsAlgorithm()
